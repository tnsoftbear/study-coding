package main

import (
	"fmt"
)

// Определяем тип ошибки ErrNegativeSqrt
type ErrNegativeSqrt float64

// Реализуем метод Error() для типа ErrNegativeSqrt
func (e ErrNegativeSqrt) Error() string {
	// Используем fmt.Sprint для преобразования float64 в строку, чтобы избежать рекурсивного вызова Error()
	return fmt.Sprintf("cannot Sqrt negative number: %v", float64(e))
}

// Функция Sqrt, возвращающая квадратный корень и ошибку, если входное число отрицательное
func Sqrt(x float64) (float64, error) {
	if x < 0 {
		return 0, ErrNegativeSqrt(x)
	}
	// Простой алгоритм для нахождения квадратного корня методом Ньютона
	z := x
	for i := 0; i < 10; i++ {
		z -= (z*z - x) / (2 * z)
	}
	return z, nil
}

func main() {
	// Пример вызова Sqrt с положительным числом
	fmt.Println(Sqrt(2))

	// Пример вызова Sqrt с отрицательным числом
	fmt.Println(Sqrt(-2))
}

/**

## Почему fmt.Sprint(e) вызывает Error()?

В Go, любой тип, который реализует метод `Error() string`, считается реализацией интерфейса `error`.
Когда функция из пакета `fmt` (например, `fmt.Sprint`, `fmt.Sprintf`, и т.д.) видит, что аргумент реализует интерфейс `error`,
она автоматически вызывает метод `Error()` этого типа для получения строкового представления ошибки.

Тип `ErrNegativeSqrt` реализует метод `Error()`: В вашем коде тип `ErrNegativeSqrt` реализует метод `Error()`.
Следовательно, если вы передадите значение типа `ErrNegativeSqrt` в `fmt.Sprint(e)`, `fmt` обнаружит, что это значение реализует интерфейс `error`,
и вызовет метод `Error()` для получения строкового представления.

Рекурсия: Если внутри метода Error() вы попытаетесь вызвать fmt.Sprint(e), произойдет следующее:

* `fmt.Sprint(e)` распознает, что e является типом, реализующим интерфейс `error`.
* Он вызывает `e.Error()`.
* Поскольку метод `Error()` содержит вызов `fmt.Sprint(e)`, это приведет к вызову `Error()` снова.
* Этот цикл будет повторяться бесконечно, что приведет к рекурсивному вызову метода `Error()` и в конечном итоге к панике программы из-за переполнения стека.

Чтобы избежать этой рекурсии, необходимо явно преобразовать `e` к типу, который не реализует интерфейс `error`, прежде чем передавать его в `fmt.Sprint` или `fmt.Sprintf`.
В вашем примере `float64(e)` преобразует значение `e` к типу `float64`. Тип `float64` не имеет метода `Error()`, поэтому `fmt.Sprintf` не будет пытаться снова вызвать `Error()`,
и рекурсии не произойдет. Вместо этого `fmt.Sprintf` просто форматирует `float64` значение как строку и вставляет его в форматированное сообщение.


https://go.dev/tour/methods/20
*/
